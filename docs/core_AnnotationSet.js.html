<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/AnnotationSet.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/AnnotationSet.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Annotation from './Annotation';

/**
 * Annotations set provides access to
 * Document annotation
 * @class nlpjs.core.AnnotationSet
 * @property {number} size number of annotations in set
 * @property {nlpjs.core.Annotation} first first annotation in set
 * @property {nlpjs.core.Annotation} last  last annotation in set
 * @property {boolean} isEmpty emptiness of set
 * @param {nlpjs.core.Document} document document this annotation belongs to
 * @param {object} [set] initial set of annotations
 */
export default class AnnotationSet {


    constructor(document, set){
        this._document = document;
        var self = this;
        if (set === undefined){
            this._data = [];
        } else {
            this._data = set.map(function(x){
                if (x instanceof Annotation){
                    return x;
                }
                return new Annotation(self, x.start, x.end, x.type, x.features);
            });
        }
        this._sort();
        this._listeners = {};
    }

    /**
     * @method nlpjs.core.AnnotationSet#createAnnotation
     * @static
     */
    static createAnnotation(start, end, type, features){
        return new Annotation(undefined, start, end, type, features);
    }

    /**
     * @method nlpjs.core.AnnotationSet#cloneAnnotation
     * @static
     */
    static cloneAnnotation(annotation){
        return annotation.clone();
    }

    /**
     * Adds new annotation into set
     * @method nlpjs.core.AnnotationSet#add
     * @param {number} start index of start of the annotation
     * @param {number} end      index of end of the annotation
     * @param {string} type     type of annotation (html, pos, ie.)
     * @param {object} features object containing features of annotation
     * @returns {nlpjs.core.AnnotationSet} self for chaining
     */
    add(start, end, type, features) {
        var annotation, i, ii;
        if (arguments.length > 1){
            annotation = AnnotationSet.createAnnotation(start, end, type, features);
        } else {
            annotation = start;
        }

        if (Object.prototype.toString.call(annotation) !== '[object Array]'){
            annotation = [annotation];
        }
        for(i = 0, ii = annotation.length;i&lt;ii;i++){
            annotation[i]._set = this;
        }

        this._data = this._data.concat(annotation);
        this._sort();
        if (this._listeners.add) {
            for(i = 0, ii = this._listeners.add.length; i&lt;ii;i++){
                this._listeners.add[i](annotation);
            }
        }
        return this;
    }

    /**
     * @method nlpjs.core.AnnotationSet#del
     * @param {Annotation|Array&lt;Annotation>} annotations
     * @returns {AnnotationSet}
     */
    del(annotations){
        if (Object.prototype.toString.call(annotations) !== '[object Array]'){
            annotations = [annotations];
        }
        this._data = this._data.filter(function(an){
            for (var i=0,ii=annotations.length;i&lt;ii;i++){
                var annotation = annotations[i];
                if (annotation.type  === an.type &amp;&amp;
                    annotation.start === an.start &amp;&amp;
                    annotation.end   === an.end)
                    return false;
            }
            return true;
        });
        if (this._listeners.del) {
            for(var i = 0, ii = this._listeners.del.length; i&lt;ii;i++){
                this._listeners.del[i](annotations);
            }
        }
        return this;
    }

    /**
     * Filters annotations by type
     * @method nlpjs.core.AnnotationSet#type
     * @param  {string} type type of annotation
     * @returns {nlpjs.core.AnnotationSet} filtered set
     */
    type(type) {
        return this.filter(function(annotation){
            return annotation.type === type;
        });
    }

    /**
     * Returns annotations at least partially overlapping selection
     * @method nlpjs.core.AnnotationSet#get
     * @param  {number} startOffset index of start of selection
     * @param  {number} endOffset   index of end of selection
     * @return {nlpjs.core.AnnotationSet} filtered set
     */
    /**
     * Returns first annotation that starts at or after
     * index and all other annotations
     * that starts at index of found annotation
     * @method nlpjs.core.AnnotationSet#get
     * @param  {number} startOffset index
     * @return {nlpjs.core.AnnotationSet} filtered set
     */
    get(startOffset, endOffset) {
        var pred;
        if (endOffset !== undefined) {
            pred = function(annotation) {
                return annotation.start &lt; endOffset &amp;&amp; annotation.end > startOffset;
            };
        } else {
            pred = (function() {
                var max = Infinity;
                return function(annotation){
                    if (annotation.start >= startOffset &amp;&amp; annotation.start &lt;= max){
                        max = annotation.start;
                        return true;
                    }
                    return false;
                };
            })();
        }
        return this.filter(pred);
    }

    /**
     * @method nlpjs.core.AnnotationSet#filter
     * @param  {function} pred filtering predicate
     * @return {nlpjs.core.AnnotationSet} filtered set
     */
    filter(pred) {
        return new AnnotationSet(this._document, this._data.filter(pred));
    }

    /**
     * @method nlpjs.core.AnnotationSet#each
     * @param  {function} fb callback (annotation and index is provided)
     * @return {nlpjs.core.AnnotationSet} self for chaining
     */
    each(fn) {
        for (var i = 0, ii = this._data.length; i &lt; ii; i += 1){
            if (this._data[i].start >= 0 &amp;&amp; this._data[i].end >= 0)
                fn.call(fn, this._data[i], i);
        }
        return this;
    }

    /**
     * @method nlpjs.core.AnnotationSet#map
     * @param fn
     * @returns {Array}
     */
    map(fn){
        var arr = [];
        for (var i = 0, ii = this._data.length; i &lt; ii; i += 1){
            arr.push(fn.call(fn, this._data[i], i));
        }
        return arr;
    }

    /**
     * Subscribe to changes
     * @method nlpjs.core.AnnotationSet#listen
     * @param type
     * @param callback
     */
    listen(type, callback) {
        this._listeners[type] = this._listeners[type] || [];
        this._listeners[type].push(callback);
    }

    /**
     * @readOnly
     */
    get first() {
        return this._data[0];
    }

    /**
     * @readOnly
     */
    get last() {
        return this._data[this.size-1];
    }

    /**
     * @readOnly
     */
    get size() {
        return this._data.length;
    }


    /**
     * @readOnly
     */
    get length() {
        return this.size;
    }


    /**
     * @readOnly
     */
    get isEmpty() {
        return this.size === 0;
    }

    /**
     * @private
     * @name nlpjs.core.AnnotationSet#_sort
     */
    _sort(){
        this._data.sort(function(a, b){
            if (a.start &lt; b.start)
                return -1;
            else if (a.start > b.start)
                return 1;
            else if (a.end &lt; b.end)
                return -1;
            else if (a.end > b.end)
                return 1;
            else
                return 0;
        });
        return this;
    }

}

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="nlpjs.classifier.AdaBoost.html">AdaBoost</a></li><li><a href="nlpjs.classifier.NaiveBayes.html">NaiveBayes</a></li><li><a href="nlpjs.classifier.NGram.html">NGram</a></li><li><a href="nlpjs.core.Annotation.html">Annotation</a></li><li><a href="nlpjs.core.AnnotationSet.html">AnnotationSet</a></li><li><a href="nlpjs.core.Container.html">Container</a></li><li><a href="nlpjs.core.Corpus.html">Corpus</a></li><li><a href="nlpjs.core.Document.html">Document</a></li><li><a href="nlpjs.core.HtmlDocument.html">HtmlDocument</a></li><li><a href="nlpjs.db.sparql.DBPediaEndpoint.html">DBPediaEndpoint</a></li><li><a href="nlpjs.db.sparql.Endpoint.html">Endpoint</a></li><li><a href="nlpjs.db.sparql.Query.html">Query</a></li><li><a href="nlpjs.distance.Hamming.html">Hamming</a></li><li><a href="nlpjs.distance.Levenshtein.html">Levenshtein</a></li><li><a href="nlpjs.stemmer.Hunspell.html">Hunspell</a></li><li><a href="nlpjs.tokenizer.CsTokenizer.html">CsTokenizer</a></li><li><a href="nlpjs.tokenizer.Tokenizer.html">Tokenizer</a></li><li><a href="StringBuffer.html">StringBuffer</a></li></ul><h3>Namespaces</h3><ul><li><a href="nlpjs.classifier.html">classifier</a></li><li><a href="nlpjs.core.html">core</a></li><li><a href="nlpjs.db.sparql.html">sparql</a></li><li><a href="nlpjs.distance.html">distance</a></li><li><a href="nlpjs.helpers.html">helpers</a></li><li><a href="nlpjs.stemmer.html">stemmer</a></li><li><a href="nlpjs.tokenizer.html">tokenizer</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-beta3</a> on Sat May 02 2015 20:05:35 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
